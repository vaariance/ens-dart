// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'normalization.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

NORMALIZATION _$NORMALIZATIONFromJson(Map<String, dynamic> json) {
  return _NORMALIZATION.fromJson(json);
}

/// @nodoc
mixin _$NORMALIZATION {
  String get unicodeVersion => throw _privateConstructorUsedError;
  Set<int> get ignored => throw _privateConstructorUsedError;
  Map<int, List<int>> get mapped => throw _privateConstructorUsedError;
  Set<int> get cm => throw _privateConstructorUsedError;
  List<List<int>> get emoji => throw _privateConstructorUsedError;
  Set<int> get nfcCheck => throw _privateConstructorUsedError;
  Map<int, String> get fenced => throw _privateConstructorUsedError;
  List<Group> get groups => throw _privateConstructorUsedError;
  Set<int> get valid => throw _privateConstructorUsedError;
  @WholeMapConverter()
  Map<int, dynamic> get wholeMap => throw _privateConstructorUsedError;
  int get nsmMax => throw _privateConstructorUsedError;
  Set<int> get nsm => throw _privateConstructorUsedError;
  Map<String, String> get emojiFe0fLookup => throw _privateConstructorUsedError;
  @RegExpConverter()
  RegExp get emojiRegex => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NORMALIZATIONCopyWith<NORMALIZATION> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NORMALIZATIONCopyWith<$Res> {
  factory $NORMALIZATIONCopyWith(
          NORMALIZATION value, $Res Function(NORMALIZATION) then) =
      _$NORMALIZATIONCopyWithImpl<$Res, NORMALIZATION>;
  @useResult
  $Res call(
      {String unicodeVersion,
      Set<int> ignored,
      Map<int, List<int>> mapped,
      Set<int> cm,
      List<List<int>> emoji,
      Set<int> nfcCheck,
      Map<int, String> fenced,
      List<Group> groups,
      Set<int> valid,
      @WholeMapConverter() Map<int, dynamic> wholeMap,
      int nsmMax,
      Set<int> nsm,
      Map<String, String> emojiFe0fLookup,
      @RegExpConverter() RegExp emojiRegex});
}

/// @nodoc
class _$NORMALIZATIONCopyWithImpl<$Res, $Val extends NORMALIZATION>
    implements $NORMALIZATIONCopyWith<$Res> {
  _$NORMALIZATIONCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? unicodeVersion = null,
    Object? ignored = null,
    Object? mapped = null,
    Object? cm = null,
    Object? emoji = null,
    Object? nfcCheck = null,
    Object? fenced = null,
    Object? groups = null,
    Object? valid = null,
    Object? wholeMap = null,
    Object? nsmMax = null,
    Object? nsm = null,
    Object? emojiFe0fLookup = null,
    Object? emojiRegex = null,
  }) {
    return _then(_value.copyWith(
      unicodeVersion: null == unicodeVersion
          ? _value.unicodeVersion
          : unicodeVersion // ignore: cast_nullable_to_non_nullable
              as String,
      ignored: null == ignored
          ? _value.ignored
          : ignored // ignore: cast_nullable_to_non_nullable
              as Set<int>,
      mapped: null == mapped
          ? _value.mapped
          : mapped // ignore: cast_nullable_to_non_nullable
              as Map<int, List<int>>,
      cm: null == cm
          ? _value.cm
          : cm // ignore: cast_nullable_to_non_nullable
              as Set<int>,
      emoji: null == emoji
          ? _value.emoji
          : emoji // ignore: cast_nullable_to_non_nullable
              as List<List<int>>,
      nfcCheck: null == nfcCheck
          ? _value.nfcCheck
          : nfcCheck // ignore: cast_nullable_to_non_nullable
              as Set<int>,
      fenced: null == fenced
          ? _value.fenced
          : fenced // ignore: cast_nullable_to_non_nullable
              as Map<int, String>,
      groups: null == groups
          ? _value.groups
          : groups // ignore: cast_nullable_to_non_nullable
              as List<Group>,
      valid: null == valid
          ? _value.valid
          : valid // ignore: cast_nullable_to_non_nullable
              as Set<int>,
      wholeMap: null == wholeMap
          ? _value.wholeMap
          : wholeMap // ignore: cast_nullable_to_non_nullable
              as Map<int, dynamic>,
      nsmMax: null == nsmMax
          ? _value.nsmMax
          : nsmMax // ignore: cast_nullable_to_non_nullable
              as int,
      nsm: null == nsm
          ? _value.nsm
          : nsm // ignore: cast_nullable_to_non_nullable
              as Set<int>,
      emojiFe0fLookup: null == emojiFe0fLookup
          ? _value.emojiFe0fLookup
          : emojiFe0fLookup // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      emojiRegex: null == emojiRegex
          ? _value.emojiRegex
          : emojiRegex // ignore: cast_nullable_to_non_nullable
              as RegExp,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NORMALIZATIONImplCopyWith<$Res>
    implements $NORMALIZATIONCopyWith<$Res> {
  factory _$$NORMALIZATIONImplCopyWith(
          _$NORMALIZATIONImpl value, $Res Function(_$NORMALIZATIONImpl) then) =
      __$$NORMALIZATIONImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String unicodeVersion,
      Set<int> ignored,
      Map<int, List<int>> mapped,
      Set<int> cm,
      List<List<int>> emoji,
      Set<int> nfcCheck,
      Map<int, String> fenced,
      List<Group> groups,
      Set<int> valid,
      @WholeMapConverter() Map<int, dynamic> wholeMap,
      int nsmMax,
      Set<int> nsm,
      Map<String, String> emojiFe0fLookup,
      @RegExpConverter() RegExp emojiRegex});
}

/// @nodoc
class __$$NORMALIZATIONImplCopyWithImpl<$Res>
    extends _$NORMALIZATIONCopyWithImpl<$Res, _$NORMALIZATIONImpl>
    implements _$$NORMALIZATIONImplCopyWith<$Res> {
  __$$NORMALIZATIONImplCopyWithImpl(
      _$NORMALIZATIONImpl _value, $Res Function(_$NORMALIZATIONImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? unicodeVersion = null,
    Object? ignored = null,
    Object? mapped = null,
    Object? cm = null,
    Object? emoji = null,
    Object? nfcCheck = null,
    Object? fenced = null,
    Object? groups = null,
    Object? valid = null,
    Object? wholeMap = null,
    Object? nsmMax = null,
    Object? nsm = null,
    Object? emojiFe0fLookup = null,
    Object? emojiRegex = null,
  }) {
    return _then(_$NORMALIZATIONImpl(
      unicodeVersion: null == unicodeVersion
          ? _value.unicodeVersion
          : unicodeVersion // ignore: cast_nullable_to_non_nullable
              as String,
      ignored: null == ignored
          ? _value._ignored
          : ignored // ignore: cast_nullable_to_non_nullable
              as Set<int>,
      mapped: null == mapped
          ? _value._mapped
          : mapped // ignore: cast_nullable_to_non_nullable
              as Map<int, List<int>>,
      cm: null == cm
          ? _value._cm
          : cm // ignore: cast_nullable_to_non_nullable
              as Set<int>,
      emoji: null == emoji
          ? _value._emoji
          : emoji // ignore: cast_nullable_to_non_nullable
              as List<List<int>>,
      nfcCheck: null == nfcCheck
          ? _value._nfcCheck
          : nfcCheck // ignore: cast_nullable_to_non_nullable
              as Set<int>,
      fenced: null == fenced
          ? _value._fenced
          : fenced // ignore: cast_nullable_to_non_nullable
              as Map<int, String>,
      groups: null == groups
          ? _value._groups
          : groups // ignore: cast_nullable_to_non_nullable
              as List<Group>,
      valid: null == valid
          ? _value._valid
          : valid // ignore: cast_nullable_to_non_nullable
              as Set<int>,
      wholeMap: null == wholeMap
          ? _value._wholeMap
          : wholeMap // ignore: cast_nullable_to_non_nullable
              as Map<int, dynamic>,
      nsmMax: null == nsmMax
          ? _value.nsmMax
          : nsmMax // ignore: cast_nullable_to_non_nullable
              as int,
      nsm: null == nsm
          ? _value._nsm
          : nsm // ignore: cast_nullable_to_non_nullable
              as Set<int>,
      emojiFe0fLookup: null == emojiFe0fLookup
          ? _value._emojiFe0fLookup
          : emojiFe0fLookup // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      emojiRegex: null == emojiRegex
          ? _value.emojiRegex
          : emojiRegex // ignore: cast_nullable_to_non_nullable
              as RegExp,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NORMALIZATIONImpl implements _NORMALIZATION {
  const _$NORMALIZATIONImpl(
      {required this.unicodeVersion,
      required final Set<int> ignored,
      required final Map<int, List<int>> mapped,
      required final Set<int> cm,
      required final List<List<int>> emoji,
      required final Set<int> nfcCheck,
      required final Map<int, String> fenced,
      required final List<Group> groups,
      required final Set<int> valid,
      @WholeMapConverter() required final Map<int, dynamic> wholeMap,
      required this.nsmMax,
      required final Set<int> nsm,
      required final Map<String, String> emojiFe0fLookup,
      @RegExpConverter() required this.emojiRegex})
      : _ignored = ignored,
        _mapped = mapped,
        _cm = cm,
        _emoji = emoji,
        _nfcCheck = nfcCheck,
        _fenced = fenced,
        _groups = groups,
        _valid = valid,
        _wholeMap = wholeMap,
        _nsm = nsm,
        _emojiFe0fLookup = emojiFe0fLookup;

  factory _$NORMALIZATIONImpl.fromJson(Map<String, dynamic> json) =>
      _$$NORMALIZATIONImplFromJson(json);

  @override
  final String unicodeVersion;
  final Set<int> _ignored;
  @override
  Set<int> get ignored {
    if (_ignored is EqualUnmodifiableSetView) return _ignored;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_ignored);
  }

  final Map<int, List<int>> _mapped;
  @override
  Map<int, List<int>> get mapped {
    if (_mapped is EqualUnmodifiableMapView) return _mapped;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_mapped);
  }

  final Set<int> _cm;
  @override
  Set<int> get cm {
    if (_cm is EqualUnmodifiableSetView) return _cm;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_cm);
  }

  final List<List<int>> _emoji;
  @override
  List<List<int>> get emoji {
    if (_emoji is EqualUnmodifiableListView) return _emoji;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_emoji);
  }

  final Set<int> _nfcCheck;
  @override
  Set<int> get nfcCheck {
    if (_nfcCheck is EqualUnmodifiableSetView) return _nfcCheck;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_nfcCheck);
  }

  final Map<int, String> _fenced;
  @override
  Map<int, String> get fenced {
    if (_fenced is EqualUnmodifiableMapView) return _fenced;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_fenced);
  }

  final List<Group> _groups;
  @override
  List<Group> get groups {
    if (_groups is EqualUnmodifiableListView) return _groups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_groups);
  }

  final Set<int> _valid;
  @override
  Set<int> get valid {
    if (_valid is EqualUnmodifiableSetView) return _valid;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_valid);
  }

  final Map<int, dynamic> _wholeMap;
  @override
  @WholeMapConverter()
  Map<int, dynamic> get wholeMap {
    if (_wholeMap is EqualUnmodifiableMapView) return _wholeMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_wholeMap);
  }

  @override
  final int nsmMax;
  final Set<int> _nsm;
  @override
  Set<int> get nsm {
    if (_nsm is EqualUnmodifiableSetView) return _nsm;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_nsm);
  }

  final Map<String, String> _emojiFe0fLookup;
  @override
  Map<String, String> get emojiFe0fLookup {
    if (_emojiFe0fLookup is EqualUnmodifiableMapView) return _emojiFe0fLookup;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_emojiFe0fLookup);
  }

  @override
  @RegExpConverter()
  final RegExp emojiRegex;

  @override
  String toString() {
    return 'NORMALIZATION(unicodeVersion: $unicodeVersion, ignored: $ignored, mapped: $mapped, cm: $cm, emoji: $emoji, nfcCheck: $nfcCheck, fenced: $fenced, groups: $groups, valid: $valid, wholeMap: $wholeMap, nsmMax: $nsmMax, nsm: $nsm, emojiFe0fLookup: $emojiFe0fLookup, emojiRegex: $emojiRegex)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NORMALIZATIONImpl &&
            (identical(other.unicodeVersion, unicodeVersion) ||
                other.unicodeVersion == unicodeVersion) &&
            const DeepCollectionEquality().equals(other._ignored, _ignored) &&
            const DeepCollectionEquality().equals(other._mapped, _mapped) &&
            const DeepCollectionEquality().equals(other._cm, _cm) &&
            const DeepCollectionEquality().equals(other._emoji, _emoji) &&
            const DeepCollectionEquality().equals(other._nfcCheck, _nfcCheck) &&
            const DeepCollectionEquality().equals(other._fenced, _fenced) &&
            const DeepCollectionEquality().equals(other._groups, _groups) &&
            const DeepCollectionEquality().equals(other._valid, _valid) &&
            const DeepCollectionEquality().equals(other._wholeMap, _wholeMap) &&
            (identical(other.nsmMax, nsmMax) || other.nsmMax == nsmMax) &&
            const DeepCollectionEquality().equals(other._nsm, _nsm) &&
            const DeepCollectionEquality()
                .equals(other._emojiFe0fLookup, _emojiFe0fLookup) &&
            (identical(other.emojiRegex, emojiRegex) ||
                other.emojiRegex == emojiRegex));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      unicodeVersion,
      const DeepCollectionEquality().hash(_ignored),
      const DeepCollectionEquality().hash(_mapped),
      const DeepCollectionEquality().hash(_cm),
      const DeepCollectionEquality().hash(_emoji),
      const DeepCollectionEquality().hash(_nfcCheck),
      const DeepCollectionEquality().hash(_fenced),
      const DeepCollectionEquality().hash(_groups),
      const DeepCollectionEquality().hash(_valid),
      const DeepCollectionEquality().hash(_wholeMap),
      nsmMax,
      const DeepCollectionEquality().hash(_nsm),
      const DeepCollectionEquality().hash(_emojiFe0fLookup),
      emojiRegex);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NORMALIZATIONImplCopyWith<_$NORMALIZATIONImpl> get copyWith =>
      __$$NORMALIZATIONImplCopyWithImpl<_$NORMALIZATIONImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$NORMALIZATIONImplToJson(
      this,
    );
  }
}

abstract class _NORMALIZATION implements NORMALIZATION {
  const factory _NORMALIZATION(
          {required final String unicodeVersion,
          required final Set<int> ignored,
          required final Map<int, List<int>> mapped,
          required final Set<int> cm,
          required final List<List<int>> emoji,
          required final Set<int> nfcCheck,
          required final Map<int, String> fenced,
          required final List<Group> groups,
          required final Set<int> valid,
          @WholeMapConverter() required final Map<int, dynamic> wholeMap,
          required final int nsmMax,
          required final Set<int> nsm,
          required final Map<String, String> emojiFe0fLookup,
          @RegExpConverter() required final RegExp emojiRegex}) =
      _$NORMALIZATIONImpl;

  factory _NORMALIZATION.fromJson(Map<String, dynamic> json) =
      _$NORMALIZATIONImpl.fromJson;

  @override
  String get unicodeVersion;
  @override
  Set<int> get ignored;
  @override
  Map<int, List<int>> get mapped;
  @override
  Set<int> get cm;
  @override
  List<List<int>> get emoji;
  @override
  Set<int> get nfcCheck;
  @override
  Map<int, String> get fenced;
  @override
  List<Group> get groups;
  @override
  Set<int> get valid;
  @override
  @WholeMapConverter()
  Map<int, dynamic> get wholeMap;
  @override
  int get nsmMax;
  @override
  Set<int> get nsm;
  @override
  Map<String, String> get emojiFe0fLookup;
  @override
  @RegExpConverter()
  RegExp get emojiRegex;
  @override
  @JsonKey(ignore: true)
  _$$NORMALIZATIONImplCopyWith<_$NORMALIZATIONImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
